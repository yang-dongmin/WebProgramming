# React 핵심 개념 정리

## Lists & Keys

리스트는 배열 형태의 데이터를 기반으로 여러 컴포넌트를 렌더링할 때 사용합니다.

### map() 함수
- 배열(Array)의 각 요소를 변환하여 새로운 배열을 생성하는 JavaScript 배열 메서드
- 원본 배열을 변경하지 않고, 새로운 배열을 반환
- React에서 리스트를 동적으로 렌더링할 때 필수적으로 사용

```javascript
array.map(callbackFunction(currentValue, index, array), thisArg);
```

- `array`: map() 함수를 호출하는 원본 배열
- `callbackFunction`: 각 요소에 대해 실행할 함수
  - `currentValue`: 현재 처리 중인 배열 요소
  - `index` (선택 사항): 현재 처리 중인 요소의 인덱스
  - `array` (선택 사항): map() 함수를 호출한 원본 배열
- `thisArg` (선택 사항): callbackFunction 내부에서 this로 사용할 값

### Keys
- 키는 각 객체나 아이템을 구분할 수 있는 고유한 값
- 리액트에서 키는 아이템들을 구분하기 위한 고유한 문자열
- 리스트의 각 항목에는 고유한 키(key 속성)를 추가해야 함
- 키는 React가 어떤 항목이 변경, 추가, 제거되었는지 식별하는 데 사용
- 키를 사용하면 리액트가 리스트를 효율적으로 업데이트할 수 있음

## Forms

사용자의 입력을 처리하고 데이터를 서버로 전송하는 데 사용합니다.

### Form 구성요소
- `<form>` 태그: Form 전체를 감싸는 태그
- `<input>`, `<textarea>`, `<select>` 등의 입력 요소: 사용자로부터 데이터를 입력받는 요소
- `onChange` 이벤트 핸들러: 입력 요소의 값이 변경될 때 호출되는 함수
- `onSubmit` 이벤트 핸들러: Form이 제출될 때 호출되는 함수
- 상태(State): 입력 요소의 값을 저장하고 관리하는 변수

### Form 작동 방식
1. 초기 상태 설정: 각 입력 요소의 초기값을 상태로 설정
2. 입력 요소 렌더링: 상태를 기반으로 입력 요소를 렌더링
3. onChange 이벤트 처리: 사용자가 입력 요소의 값을 변경하면 onChange 이벤트 핸들러가 호출되고, 상태를 업데이트
4. onSubmit 이벤트 처리: 사용자가 Form을 제출하면 onSubmit 이벤트 핸들러가 호출되고, 상태에 저장된 데이터를 서버로 전송
5. 상태 업데이트 및 렌더링: 서버 응답에 따라 상태를 업데이트하고, UI를 다시 렌더링

### 제어 컴포넌트와 비제어 컴포넌트
- HTML Form은 자체적으로 state를 관리하지만, 제어 컴포넌트(Controlled Component)는 모든 데이터를 state에서 관리
- 비제어 컴포넌트(Uncontrolled Component)는 useState 대신 useRef를 사용하여 입력 값을 직접 참조

## Lifting State Up (상태 끌어올리기)

상태를 부모 컴포넌트로 올려서 중앙에서 관리하는 방식입니다.

### 특징
- 하위 컴포넌트의 상태를 부모 컴포넌트로 이동시키는 패턴
- 여러 하위 컴포넌트가 동일한 상태를 공유하거나, 하위 컴포넌트의 변경 사항을 부모 컴포넌트에서 처리해야 할 때 유용
- 리액트는 단방향 데이터 흐름을 따르기 때문에, 하위 컴포넌트에서 부모 컴포넌트의 상태를 직접 변경할 수 없음

### 구현 방법
1. 상태 정의: 하위 컴포넌트에서 사용될 상태를 부모 컴포넌트에 정의
2. 상태 변경 함수 전달: 부모 컴포넌트에서 상태를 변경하는 함수를 정의하고, 이 함수를 하위 컴포넌트에 props로 전달
3. 상태 변경 함수 호출: 하위 컴포넌트에서 이벤트 발생 시 props로 전달받은 상태 변경 함수를 호출하여 부모 컴포넌트의 상태를 변경
4. 상태 전달: 부모 컴포넌트에서 변경된 상태를 props를 통해 하위 컴포넌트에 전달

### 필요한 이유
- 두 개의 자식 컴포넌트가 동일한 데이터를 공유해야 하는 경우, 각 자식 컴포넌트가 별도로 상태를 관리하면 데이터 동기화 문제가 발생할 수 있음
- 해결 방법: 부모에서 상태를 관리하고, props로 내려주기

## Composition vs Inheritance

"컴포넌트가 자신의 출력에 다른 컴포넌트를 참조"하는 것입니다.

### 합성(Composition)
- 컴포넌트를 조합하여 더 복잡한 UI를 만드는 방법
- 여러 개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것
- 리액트에서는 props를 사용하여 컴포넌트 간에 데이터를 전달하고, children props를 통해 다른 컴포넌트를 포함할 수 있음

### 합성 패턴
1. **Containment (포함) 패턴**
   - 컴포넌트 내부에 다른 컴포넌트를 포함할 때 사용
   - children을 이용하여 컴포넌트의 내용을 유연하게 변경 가능
   - 하위 컴포넌트를 포함하는 형태의 합성 방법

2. **Specialization (특화) 패턴**
   - 특정 역할을 수행하는 컴포넌트를 만들 때 사용
   - 부모 컴포넌트의 기본 구조를 유지하면서, 일부만 변경 가능
   - Welcome Dialog는 Dialog의 특별한 케이스
   - 범용적인 개념을 구별이 되게 구체화하는 것

3. **Higher-Order Components (HOC)**
   - HOC는 컴포넌트를 감싸서 기능을 확장하는 패턴
   - React Hooks 이후 HOC보다 Custom Hook이 더 많이 사용됨

### 상속(Inheritance)
- React는 전통적인 객체지향 프로그래밍(OOP) 방식의 상속을 잘 사용하지 않음
- React에서는 컴포넌트를 상속하는 대신, 합성을 사용하는 것이 일반적
- 리액트 공식 문서에서는 상속보다는 합성을 사용하여 컴포넌트 간 코드를 재사용하는 것을 권장